
# -- num/rk8pd.lua.in
# --
# -- Copyright (C) 2009-2011 Francesco Abbate
# --
# -- This program is free software; you can redistribute it and/or modify
# -- it under the terms of the GNU General Public License as published by
# -- the Free Software Foundation; either version 3 of the License, or (at
# -- your option) any later version.
# --
# -- This program is distributed in the hope that it will be useful, but
# -- WITHOUT ANY WARRANTY; without even the implied warranty of
# -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# -- General Public License for more details.
# --
# -- You should have received a copy of the GNU General Public License
# -- along with this program; if not, write to the Free Software
# -- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
# --

# -- Adapted from the GSL Library, version 1.14

# -- Runge-Kutta 8(9), Prince-Dormand
# --
# -- High Order Embedded Runge-Kutta Formulae
# -- P.J. Prince and J.R. Dormand
# -- J. Comp. Appl. Math.,7, pp. 67-75, 1981

# -- Original author:  G. Jungman
# -- Modified for LuaJIT2: Francesco Abbate

local abs, max, min = math.abs, math.max, math.min

# order = 8

local ffi = require 'ffi'
local gsl = require 'gsl'
local cblas = require 'cblas'

local RowMajor, Trans, NoTrans = gsl.CblasRowMajor, gsl.CblasTrans, gsl.CblasNoTrans

local function hadjust(rmax, h)
   local S = 0.9
   if rmax > 1.1 then
      local r = S / rmax^(1/$(order))
      r = max(0.2, r)
      return r * h, -1
   elseif rmax < 0.5 then
      local r = S / rmax^(1/($(order)+1))
      r = max(1, min(r, 5))
      return r * h, 1
   end
   return h, 0
end

# ah = {
#    '1/18',
#    '1/12',
#    '1/8',
#    '5/16',
#    '3/8',
#    '59/400',
#    '93/200',
#    '5490023248/9719169821',
#    '13/20',
#    '1201146811/1299019798',
#    '1',
#    '1' }

Abar = ffi.new('double[13]',
	   14005451/335480064,
	   0,
	   0,
	   0,
	   0,
          -59238493/1068277825,
	   181606767/758867731,
	   561292985/797845732,
          -1041891430/1371343529,
	   760417239/1151165299,
	   118820643/751138087,
          -528747749/2220607170,
	   1/4 )

A = ffi.new('double[12]',
    13451932/455176623,
    0,
    0,
    0,
    0,
    -808719846/976000145,
    1757004468/5645159321,
    656045339/265891186,
    -3867574721/1518517206,
    465885868/322736535,
    53011238/667516719,
    2/45 )

B2 = ffi.new('double[1]', 1/18 )
B3 = ffi.new('double[2]', 1/48, 1/16 )
B4 = ffi.new('double[3]', 1/32, 0, 3/32 )
B5 = ffi.new('double[4]', 5/16, 0, -75/64, 75/64 )
B6 = ffi.new('double[5]', 3/80, 0, 0, 3/16, 3/20 )
B7 = ffi.new('double[6]',
   29443841/614563906,
   0,
   0,
   77736538/692538347,
   -28693883/1125000000,
    23124283/1800000000 )

B8 = ffi.new('double[7]',
   16016141/946692911,
   0,
   0,
   61564180/158732637,
   22789713/633445777,
   545815736/2771057229,
   -180193667/1043307555 )

B9 = ffi.new('double[8]',
   39632708/573591083,
   0,
   0,
   -433636366/683701615,
   -421739975/2616292301,
   100302831/723423059,
   790204164/839813087,
   800635310/3783071287 )

B10 = ffi.new('double[9]',
   246121993/1340847787,
   0,
   0,
   -37695042795/15268766246,
   -309121744/1061227803,
   -12992083/490766935,
   6005943493/2108947869,
   393006217/1396673457,
   123872331/1001029789 )

B11 = ffi.new('double[10]',
   -1028468189/846180014,
   0,
   0,
   8478235783/508512852,
   1311729495/1432422823,
   -10304129995/1701304382,
   -48777925059/3047939560,
   15336726248/1032824649,
   -45442868181/3398467696,
   3065993473/597172653 )

B12 = ffi.new('double[11]',
   185892177/718116043,
   0,
   0,
   -3185094517/667107341,
   -477755414/1098053517,
   -703635378/230739211,
   5731566787/1027545527,
   5232866602/850066563,
   -4093664535/808688257,
   3962137247/1805957418,
   65686358/487910083 )

B13 = ffi.new('double[12]',
   403863854/491063109,
   0,
   0,
   -5068492393/434740067,
   -411421997/543043805,
   652783627/914296604,
   11173962825/925320556,
   -13158990841/6184727034,
   3936647629/1978049680,
   -160528059/685178525,
   248638103/1413531060,
   0 )

# y_err_only = (a_dydt == 0)

local function rk8pd_vec_evolve(s, f, t1)
   local t, h, s_y, s_dydt = s.t, s.h, s.y, s.dydt
   local hadj, inc

   local k, y = s.k, s.ytmp1
   cblas.cblas_dcopy($(N), s_dydt, 1, k, 1)

   if t + h > t1 then h = t1 - t end

   while h > 0 do
      cblas.cblas_dcopy($(N), s_y, 1, y, 1)
      local rmax = 0

      do
      local ytmp = s.ytmp2

#     for S = 2, 13 do
         cblas.cblas_dcopy($(N), y, 1, ytmp, 1)
         cblas.cblas_dgemm(RowMajor, Trans, NoTrans, $(N), 1, $(S-1), h, k, $(N), B$(S), 1, 1.0, ytmp, 1)
         f(t + $(ah[S-1]) * h, ytmp, k + $((S-1) * N))
#     end

      local ksum8 = s.ksum8
      cblas.cblas_dgemm(RowMajor, Trans, NoTrans, $(N), 1, 13, 1.0, k, $(N), Abar, 1, 0.0, ksum8, 1)

      cblas.cblas_daxpy($(N), h, ksum8, 1, y, 1)

#     if not y_err_only then
         f(t + h, y, s_dydt)
#     end

      do
      local yerr

      local ksum7 = s.ksum7
      cblas.cblas_dgemm(RowMajor, Trans, NoTrans, $(N), 1, 12, 1.0, k, $(N), A, 1, 0.0, ksum7, 1)

      for i = 0, $(N-1) do
         yerr = h * (ksum7[i] - ksum8[i])
#     if y_err_only then
         d0 = $(eps_rel) * ($(a_y) * abs(y[i])) + $(eps_abs)
#     else
         d0 = $(eps_rel) * ($(a_y) * abs(y[i])) + $(a_dydt) * abs(h * s_dydt[i]) + $(eps_abs)
#     end
         r = abs(yerr) / abs(d0)
         rmax = max(r, rmax)
      end
      end
      end

      hadj, inc = hadjust(rmax, h)
      if inc >= 0 then break end

      h = hadj
   end

#  if y_err_only then
      f(t + h, y, s_dydt)
#  end

   cblas.cblas_dcopy($(N), y, 1, s_y, 1)
   s.t = t + h
   s.h = hadj

   return h
end

local function ode_vec_new()
   local n = $(N)
   local ws = matrix.new(6 + 13, n)
   return {t    = 0,
	   h    = 1,
	   dim  = n,

	   y     = ws.data,
	   dydt  = ws.data + n,
	   ksum8 = ws.data + 2*n,
	   ytmp1 = ws.data + 3*n,
	   ytmp2 = ws.data + 4*n,
	   ksum7 = ws.data + 5*n,

	   k     = ws.data + 6*n,

	   -- ensure that allocated data is not collected
	   __ws = ws,
	}
end

local function ode_vec_init(s, t0, h0, f, y)
   cblas.cblas_dcopy($(N), y, 1, s.y, 1)
   f(t0, y, s.dydt)
   s.t = t0
   s.h = h0
end

return {new= ode_vec_new, init= ode_vec_init, evolve= rk8pd_vec_evolve}
